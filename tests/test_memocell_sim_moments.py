
# for package testing with pytest call
# in upper directory "$ python setup.py pytest"
# or in this directory "$ py.test test_memocell_[...].py"
# or after pip installation $py.test --pyargs memocell$

import pytest
import memocell as me
import numpy as np


class TestMomentsSimClass(object):
    ### single method tests

    # NOTE: add stuff if necessary

    ### NOTE: here we test more the symbolic attributes that are generated by the
    ### preparation methods; whole-simulations are tested in test_memocell_simulation.py
    def test_sim_moment_net_diff_markov(self):
        t = [
        {'start': 'X_t', 'end': 'Y_t', 'rate_symbol': 'k_xy', 'type': 'S -> E', 'reaction_steps': 1}
        ]
        net = me.Network('net_diff_exp')
        net.structure(t)

        simulation_variables = {'X_t': ('X_t',), 'Y_t': ('Y_t', )}
        mean_only = False
        sim = me.Simulation(net)
        sim.sim_mean_only = mean_only

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_moments.prepare_moment_simulation(sim.sim_variables_order, sim.sim_variables_identifier, mean_only)

        # check all testable attributes for the simulation of this network
        assert(sim.sim_moments.moment_order_main == [[('Z_0',), ('Z_1',)], [('Z_0', 'Z_0'), ('Z_0', 'Z_1'), ('Z_1', 'Z_1')]])
        assert(sim.sim_moments.moment_order_hidden == [[('Z_0__centric',), ('Z_1__centric',)],
                                                         [('Z_0__centric', 'Z_0__centric'),
                                                          ('Z_0__centric', 'Z_1__centric'),
                                                          ('Z_1__centric', 'Z_1__centric')]])
        assert(sim.sim_moments.moment_aux_vars == ['z_0__centric_q', 'z_1__centric_q'])
        assert(sim.sim_moments.moment_aux_vars_dict == {'Z_0__centric': 'z_0__centric_q', 'Z_1__centric': 'z_1__centric_q'})
        assert(sim.sim_moments.theta_replaceable == ['theta_0_q'])
        assert(sim.sim_moments.theta_replaceable_dict == {'theta_0': 'theta_0_q'})
        assert(sim.sim_moments.moment_pde == '1.0 * theta_0_q * (z_1__centric_q - z_0__centric_q) * diff(F(z_0__centric_q, z_1__centric_q), z_0__centric_q)')
        assert(sim.sim_moments.moment_eqs == ['-1.0*m[0]*theta[0]',
                                                 '1.0*m[0]*theta[0]',
                                                 '-2.0*m[2]*theta[0]',
                                                 '1.0*m[2]*theta[0] - 1.0*m[3]*theta[0]',
                                                 '2.0*m[3]*theta[0]'])
        assert(sim.sim_moments.moment_eqs_template_str == '@jit(nopython=True)\ndef _moment_eqs_template(m, time, theta):\n\treturn np.array([\n\t-1.0*m[0]*theta[0],\n\t1.0*m[0]*theta[0],\n\t-2.0*m[2]*theta[0],\n\t1.0*m[2]*theta[0] - 1.0*m[3]*theta[0],\n\t2.0*m[3]*theta[0]\n\t])')
        assert(np.all(sim.sim_moments.moment_mean_ind.tolist() == [[(0,)], [(1,)]]))
        assert(np.all(sim.sim_moments.moment_var_ind_intra.tolist() == [[(2,), (0,)], [(4,), (1,)]]))
        assert(np.all(sim.sim_moments.moment_var_ind_inter.tolist() == [[(), (), ()], [(), (), ()]]))
        assert(np.all(sim.sim_moments.moment_cov_ind.tolist() == [[(3,), (0,), (1,)]]))
        assert(sim.sim_moments.moment_num_means == 2)
        assert(sim.sim_moments.moment_num_vars == 2)
        assert(sim.sim_moments.moment_num_covs == 1)
        assert(np.all(sim.sim_moments.variables_mean_ind.tolist() == [[(0,)], [(1,)]]))
        assert(np.all(sim.sim_moments.variables_var_ind.tolist() == [[(0,), ()], [(1,), ()]]))
        assert(np.all(sim.sim_moments.variables_cov_ind.tolist() == [[(), (0,)]]))
        assert(sim.sim_moments.variables_num_means == 2)
        assert(sim.sim_moments.variables_num_vars == 2)
        assert(sim.sim_moments.variables_num_covs == 1)
        assert(sim.sim_moments.net_hidden_edges == [('Z_0__centric',
                                                      'Z_1__centric',
                                                      0,
                                                      {'edge_start_end_identifier': ('Z_0__centric', 'Z_1__centric'),
                                                       'edge_centric_start_end_identifier': ('Z_0__centric', 'Z_1__centric'),
                                                       'module_start_end_identifier': ('Z_0', 'Z_1'),
                                                       'module_start_end': ('X_t', 'Y_t'),
                                                       'edge_rate_symbol_identifier': '1.0 * theta_0',
                                                       'edge_rate_symbol': '1.0 * k_xy',
                                                       'module_rate_symbol_identifier': 'theta_0',
                                                       'module_rate_symbol': 'k_xy',
                                                       'module_identifier': 'module_0',
                                                       'edge_type': 'S -> E',
                                                       'module_type': 'S -> E',
                                                       'module_steps': 1})])

    def test_sim_moment_net_diff_erl3(self):
        t = [
        {'start': 'X_t', 'end': 'Y_t', 'rate_symbol': 'k_xy', 'type': 'S -> E', 'reaction_steps': 3}
        ]
        net = me.Network('net_diff_erl3')
        net.structure(t)

        simulation_variables = {'X_t': ('X_t',), 'Y_t': ('Y_t', )}
        mean_only = False
        sim = me.Simulation(net)
        sim.sim_mean_only = mean_only

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_moments.prepare_moment_simulation(sim.sim_variables_order, sim.sim_variables_identifier, mean_only)

        # check all testable attributes for the simulation of this network
        assert(sim.sim_moments.moment_order_main == [[('Z_0',), ('Z_1',)], [('Z_0', 'Z_0'), ('Z_0', 'Z_1'), ('Z_1', 'Z_1')]])
        assert(sim.sim_moments.moment_order_hidden == [[('Z_0__centric',),
                                                          ('Z_0__module_0__0',),
                                                          ('Z_0__module_0__1',),
                                                          ('Z_1__centric',)],
                                                         [('Z_0__centric', 'Z_0__centric'),
                                                          ('Z_0__centric', 'Z_0__module_0__0'),
                                                          ('Z_0__centric', 'Z_0__module_0__1'),
                                                          ('Z_0__centric', 'Z_1__centric'),
                                                          ('Z_0__module_0__0', 'Z_0__module_0__0'),
                                                          ('Z_0__module_0__0', 'Z_0__module_0__1'),
                                                          ('Z_0__module_0__0', 'Z_1__centric'),
                                                          ('Z_0__module_0__1', 'Z_0__module_0__1'),
                                                          ('Z_0__module_0__1', 'Z_1__centric'),
                                                          ('Z_1__centric', 'Z_1__centric')]])
        assert(sim.sim_moments.moment_aux_vars == ['z_0__centric_q',
                                                     'z_0__module_0__0_q',
                                                     'z_0__module_0__1_q',
                                                     'z_1__centric_q'])
        assert(sim.sim_moments.moment_aux_vars_dict == {'Z_0__centric': 'z_0__centric_q',
                                                         'Z_0__module_0__0': 'z_0__module_0__0_q',
                                                         'Z_0__module_0__1': 'z_0__module_0__1_q',
                                                         'Z_1__centric': 'z_1__centric_q'})
        assert(sim.sim_moments.theta_replaceable == ['theta_0_q'])
        assert(sim.sim_moments.theta_replaceable_dict == {'theta_0': 'theta_0_q'})
        assert(sim.sim_moments.moment_pde == '3.0 * theta_0_q * (z_0__module_0__0_q - z_0__centric_q) * diff(F(z_0__centric_q, z_0__module_0__0_q, z_0__module_0__1_q, z_1__centric_q), z_0__centric_q) + 3.0 * theta_0_q * (z_0__module_0__1_q - z_0__module_0__0_q) * diff(F(z_0__centric_q, z_0__module_0__0_q, z_0__module_0__1_q, z_1__centric_q), z_0__module_0__0_q) + 3.0 * theta_0_q * (z_1__centric_q - z_0__module_0__1_q) * diff(F(z_0__centric_q, z_0__module_0__0_q, z_0__module_0__1_q, z_1__centric_q), z_0__module_0__1_q)')
        assert(sim.sim_moments.moment_eqs == ['-3.0*m[0]*theta[0]',
                                                 '3.0*m[0]*theta[0] - 3.0*m[1]*theta[0]',
                                                 '3.0*m[1]*theta[0] - 3.0*m[2]*theta[0]',
                                                 '3.0*m[2]*theta[0]',
                                                 '-6.0*m[4]*theta[0]',
                                                 '3.0*m[4]*theta[0] - 6.0*m[5]*theta[0]',
                                                 '3.0*m[5]*theta[0] - 6.0*m[6]*theta[0]',
                                                 '3.0*m[6]*theta[0] - 3.0*m[7]*theta[0]',
                                                 '6.0*m[5]*theta[0] - 6.0*m[8]*theta[0]',
                                                 '3.0*m[6]*theta[0] + 3.0*m[8]*theta[0] - 6.0*m[9]*theta[0]',
                                                 '-3.0*m[10]*theta[0] + 3.0*m[7]*theta[0] + 3.0*m[9]*theta[0]',
                                                 '-6.0*m[11]*theta[0] + 6.0*m[9]*theta[0]',
                                                 '3.0*m[10]*theta[0] + 3.0*m[11]*theta[0] - 3.0*m[12]*theta[0]',
                                                 '6.0*m[12]*theta[0]'])
        assert(sim.sim_moments.moment_eqs_template_str == '@jit(nopython=True)\ndef _moment_eqs_template(m, time, theta):\n\treturn np.array([\n\t-3.0*m[0]*theta[0],\n\t3.0*m[0]*theta[0] - 3.0*m[1]*theta[0],\n\t3.0*m[1]*theta[0] - 3.0*m[2]*theta[0],\n\t3.0*m[2]*theta[0],\n\t-6.0*m[4]*theta[0],\n\t3.0*m[4]*theta[0] - 6.0*m[5]*theta[0],\n\t3.0*m[5]*theta[0] - 6.0*m[6]*theta[0],\n\t3.0*m[6]*theta[0] - 3.0*m[7]*theta[0],\n\t6.0*m[5]*theta[0] - 6.0*m[8]*theta[0],\n\t3.0*m[6]*theta[0] + 3.0*m[8]*theta[0] - 6.0*m[9]*theta[0],\n\t-3.0*m[10]*theta[0] + 3.0*m[7]*theta[0] + 3.0*m[9]*theta[0],\n\t-6.0*m[11]*theta[0] + 6.0*m[9]*theta[0],\n\t3.0*m[10]*theta[0] + 3.0*m[11]*theta[0] - 3.0*m[12]*theta[0],\n\t6.0*m[12]*theta[0]\n\t])')
        assert(np.all(sim.sim_moments.moment_mean_ind.tolist() == [[(0, 1, 2)], [(3,)]]))
        assert(np.all(sim.sim_moments.moment_var_ind_intra.tolist() == [[(4, 8, 11), (0, 1, 2)], [(13,), (3,)]]))
        assert(np.all(sim.sim_moments.moment_var_ind_inter.tolist() == [[(5, 6, 9), (0, 0, 1), (1, 2, 2)], [(), (), ()]]))
        assert(np.all(sim.sim_moments.moment_cov_ind.tolist() == [[(7, 10, 12), (0, 1, 2), (3, 3, 3)]]))
        assert(sim.sim_moments.moment_num_means == 2)
        assert(sim.sim_moments.moment_num_vars == 2)
        assert(sim.sim_moments.moment_num_covs == 1)
        assert(np.all(sim.sim_moments.variables_mean_ind.tolist() == [[(0,)], [(1,)]]))
        assert(np.all(sim.sim_moments.variables_var_ind.tolist() == [[(0,), ()], [(1,), ()]]))
        assert(np.all(sim.sim_moments.variables_cov_ind.tolist() == [[(), (0,)]]))
        assert(sim.sim_moments.variables_num_means == 2)
        assert(sim.sim_moments.variables_num_vars == 2)
        assert(sim.sim_moments.variables_num_covs == 1)
        assert(sim.sim_moments.net_hidden_edges == [('Z_0__centric',
                                                      'Z_0__module_0__0',
                                                      0,
                                                      {'edge_start_end_identifier': ('Z_0__centric', 'Z_0__module_0__0'),
                                                       'edge_centric_start_end_identifier': ('Z_0__centric', 'Z_1__centric'),
                                                       'module_start_end_identifier': ('Z_0', 'Z_1'),
                                                       'module_start_end': ('X_t', 'Y_t'),
                                                       'edge_rate_symbol_identifier': '3.0 * theta_0',
                                                       'edge_rate_symbol': '3.0 * k_xy',
                                                       'module_rate_symbol_identifier': 'theta_0',
                                                       'module_rate_symbol': 'k_xy',
                                                       'module_identifier': 'module_0',
                                                       'edge_type': 'S -> E',
                                                       'module_type': 'S -> E',
                                                       'module_steps': 3}),
                                                     ('Z_0__module_0__0',
                                                      'Z_0__module_0__1',
                                                      0,
                                                      {'edge_start_end_identifier': ('Z_0__module_0__0', 'Z_0__module_0__1'),
                                                       'edge_centric_start_end_identifier': ('Z_0__centric', 'Z_1__centric'),
                                                       'module_start_end_identifier': ('Z_0', 'Z_1'),
                                                       'module_start_end': ('X_t', 'Y_t'),
                                                       'edge_rate_symbol_identifier': '3.0 * theta_0',
                                                       'edge_rate_symbol': '3.0 * k_xy',
                                                       'module_rate_symbol_identifier': 'theta_0',
                                                       'module_rate_symbol': 'k_xy',
                                                       'module_identifier': 'module_0',
                                                       'edge_type': 'S -> E',
                                                       'module_type': 'S -> E',
                                                       'module_steps': 3}),
                                                     ('Z_0__module_0__1',
                                                      'Z_1__centric',
                                                      0,
                                                      {'edge_start_end_identifier': ('Z_0__module_0__1', 'Z_1__centric'),
                                                       'edge_centric_start_end_identifier': ('Z_0__centric', 'Z_1__centric'),
                                                       'module_start_end_identifier': ('Z_0', 'Z_1'),
                                                       'module_start_end': ('X_t', 'Y_t'),
                                                       'edge_rate_symbol_identifier': '3.0 * theta_0',
                                                       'edge_rate_symbol': '3.0 * k_xy',
                                                       'module_rate_symbol_identifier': 'theta_0',
                                                       'module_rate_symbol': 'k_xy',
                                                       'module_identifier': 'module_0',
                                                       'edge_type': 'S -> E',
                                                       'module_type': 'S -> E',
                                                       'module_steps': 3})])

    def test_sim_moment_net_sym_div_erl3(self):
        t = [
        {'start': 'X_t', 'end': 'X_t', 'rate_symbol': 'l', 'type': 'S -> S + S', 'reaction_steps': 3}
        ]
        net = me.Network('net_sym_div_erl3')
        net.structure(t)

        simulation_variables = {'X_t': ('X_t',)}
        mean_only = False
        sim = me.Simulation(net)
        sim.sim_mean_only = mean_only

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_moments.prepare_moment_simulation(sim.sim_variables_order, sim.sim_variables_identifier, mean_only)

        # check all testable attributes for the simulation of this network
        # assert(sim.sim_moments.moment_order_main == )
        # assert(sim.sim_moments.moment_order_hidden == )
        # assert(sim.sim_moments.moment_aux_vars == )
        # assert(sim.sim_moments.moment_aux_vars_dict == )
        # assert(sim.sim_moments.theta_replaceable == )
        # assert(sim.sim_moments.theta_replaceable_dict == )
        # assert(sim.sim_moments.moment_pde == )
        # assert(sim.sim_moments.moment_eqs == )
        # assert(sim.sim_moments.moment_eqs_template_str == )
        # assert(sim.sim_moments.moment_mean_ind == )
        # assert(sim.sim_moments.moment_var_ind_intra == )
        # assert(sim.sim_moments.moment_var_ind_inter == )
        # assert(sim.sim_moments.moment_cov_ind == )
        # assert(sim.sim_moments.moment_num_means == )
        # assert(sim.sim_moments.moment_num_vars == )
        # assert(sim.sim_moments.moment_num_covs == )
        # assert(sim.sim_moments.variables_mean_ind == )
        # assert(sim.sim_moments.variables_var_ind == )
        # assert(sim.sim_moments.variables_cov_ind == )
        # assert(sim.sim_moments.variables_num_means == )
        # assert(sim.sim_moments.variables_num_vars == )
        # assert(sim.sim_moments.variables_num_covs == )
        # assert(sim.sim_moments.net_hidden_edges == )

    def test_sim_moment_net_asym_div_erl3(self):
        t = [
        {'start': 'X_t', 'end': 'Y_t', 'rate_symbol': 'l', 'type': 'S -> S + E', 'reaction_steps': 3}
        ]
        net = me.Network('net_asym_div_erl3')
        net.structure(t)

        simulation_variables = {'X_t': ('X_t',), 'Y_t': ('Y_t', )}
        mean_only = False
        sim = me.Simulation(net)
        sim.sim_mean_only = mean_only

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_moments.prepare_moment_simulation(sim.sim_variables_order, sim.sim_variables_identifier, mean_only)

        # check all testable attributes for the simulation of this network
        # assert(sim.sim_moments.moment_order_main == )
        # assert(sim.sim_moments.moment_order_hidden == )
        # assert(sim.sim_moments.moment_aux_vars == )
        # assert(sim.sim_moments.moment_aux_vars_dict == )
        # assert(sim.sim_moments.theta_replaceable == )
        # assert(sim.sim_moments.theta_replaceable_dict == )
        # assert(sim.sim_moments.moment_pde == )
        # assert(sim.sim_moments.moment_eqs == )
        # assert(sim.sim_moments.moment_eqs_template_str == )
        # assert(sim.sim_moments.moment_mean_ind == )
        # assert(sim.sim_moments.moment_var_ind_intra == )
        # assert(sim.sim_moments.moment_var_ind_inter == )
        # assert(sim.sim_moments.moment_cov_ind == )
        # assert(sim.sim_moments.moment_num_means == )
        # assert(sim.sim_moments.moment_num_vars == )
        # assert(sim.sim_moments.moment_num_covs == )
        # assert(sim.sim_moments.variables_mean_ind == )
        # assert(sim.sim_moments.variables_var_ind == )
        # assert(sim.sim_moments.variables_cov_ind == )
        # assert(sim.sim_moments.variables_num_means == )
        # assert(sim.sim_moments.variables_num_vars == )
        # assert(sim.sim_moments.variables_num_covs == )
        # assert(sim.sim_moments.net_hidden_edges == )

    def test_sim_moment_net_diff_div_erl3(self):
        t = [
        {'start': 'X_t', 'end': 'Y_t', 'rate_symbol': 'dl', 'type': 'S -> E + E', 'reaction_steps': 3}
        ]
        net = me.Network('net_diff_div_erl3')
        net.structure(t)

        simulation_variables = {'X_t': ('X_t',), 'Y_t': ('Y_t', )}
        mean_only = False
        sim = me.Simulation(net)
        sim.sim_mean_only = mean_only

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_moments.prepare_moment_simulation(sim.sim_variables_order, sim.sim_variables_identifier, mean_only)

        # check all testable attributes for the simulation of this network
        # assert(sim.sim_moments.moment_order_main == )
        # assert(sim.sim_moments.moment_order_hidden == )
        # assert(sim.sim_moments.moment_aux_vars == )
        # assert(sim.sim_moments.moment_aux_vars_dict == )
        # assert(sim.sim_moments.theta_replaceable == )
        # assert(sim.sim_moments.theta_replaceable_dict == )
        # assert(sim.sim_moments.moment_pde == )
        # assert(sim.sim_moments.moment_eqs == )
        # assert(sim.sim_moments.moment_eqs_template_str == )
        # assert(sim.sim_moments.moment_mean_ind == )
        # assert(sim.sim_moments.moment_var_ind_intra == )
        # assert(sim.sim_moments.moment_var_ind_inter == )
        # assert(sim.sim_moments.moment_cov_ind == )
        # assert(sim.sim_moments.moment_num_means == )
        # assert(sim.sim_moments.moment_num_vars == )
        # assert(sim.sim_moments.moment_num_covs == )
        # assert(sim.sim_moments.variables_mean_ind == )
        # assert(sim.sim_moments.variables_var_ind == )
        # assert(sim.sim_moments.variables_cov_ind == )
        # assert(sim.sim_moments.variables_num_means == )
        # assert(sim.sim_moments.variables_num_vars == )
        # assert(sim.sim_moments.variables_num_covs == )
        # assert(sim.sim_moments.net_hidden_edges == )

    def test_sim_moment_net_influx_markov(self):
        t = [
        {'start': 'env', 'end': 'Y_t', 'rate_symbol': 'din', 'type': '-> E', 'reaction_steps': 1}
        ]
        net = me.Network('net_influx_exp')
        net.structure(t)

        simulation_variables = {'Y_t': ('Y_t', )}
        mean_only = False
        sim = me.Simulation(net)
        sim.sim_mean_only = mean_only

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_moments.prepare_moment_simulation(sim.sim_variables_order, sim.sim_variables_identifier, mean_only)

        # check all testable attributes for the simulation of this network
        # assert(sim.sim_moments.moment_order_main == )
        # assert(sim.sim_moments.moment_order_hidden == )
        # assert(sim.sim_moments.moment_aux_vars == )
        # assert(sim.sim_moments.moment_aux_vars_dict == )
        # assert(sim.sim_moments.theta_replaceable == )
        # assert(sim.sim_moments.theta_replaceable_dict == )
        # assert(sim.sim_moments.moment_pde == )
        # assert(sim.sim_moments.moment_eqs == )
        # assert(sim.sim_moments.moment_eqs_template_str == )
        # assert(sim.sim_moments.moment_mean_ind == )
        # assert(sim.sim_moments.moment_var_ind_intra == )
        # assert(sim.sim_moments.moment_var_ind_inter == )
        # assert(sim.sim_moments.moment_cov_ind == )
        # assert(sim.sim_moments.moment_num_means == )
        # assert(sim.sim_moments.moment_num_vars == )
        # assert(sim.sim_moments.moment_num_covs == )
        # assert(sim.sim_moments.variables_mean_ind == )
        # assert(sim.sim_moments.variables_var_ind == )
        # assert(sim.sim_moments.variables_cov_ind == )
        # assert(sim.sim_moments.variables_num_means == )
        # assert(sim.sim_moments.variables_num_vars == )
        # assert(sim.sim_moments.variables_num_covs == )
        # assert(sim.sim_moments.net_hidden_edges == )

    def test_sim_moment_net_efflux_erl3(self):
        t = [
        {'start': 'X_t', 'end': 'env', 'rate_symbol': 'dout', 'type': 'S ->', 'reaction_steps': 3}
        ]
        net = me.Network('net_efflux_erl3')
        net.structure(t)

        simulation_variables = {'X_t': ('X_t',)}
        mean_only = False
        sim = me.Simulation(net)
        sim.sim_mean_only = mean_only

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_moments.prepare_moment_simulation(sim.sim_variables_order, sim.sim_variables_identifier, mean_only)

        # check all testable attributes for the simulation of this network
        # assert(sim.sim_moments.moment_order_main == )
        # assert(sim.sim_moments.moment_order_hidden == )
        # assert(sim.sim_moments.moment_aux_vars == )
        # assert(sim.sim_moments.moment_aux_vars_dict == )
        # assert(sim.sim_moments.theta_replaceable == )
        # assert(sim.sim_moments.theta_replaceable_dict == )
        # assert(sim.sim_moments.moment_pde == )
        # assert(sim.sim_moments.moment_eqs == )
        # assert(sim.sim_moments.moment_eqs_template_str == )
        # assert(sim.sim_moments.moment_mean_ind == )
        # assert(sim.sim_moments.moment_var_ind_intra == )
        # assert(sim.sim_moments.moment_var_ind_inter == )
        # assert(sim.sim_moments.moment_cov_ind == )
        # assert(sim.sim_moments.moment_num_means == )
        # assert(sim.sim_moments.moment_num_vars == )
        # assert(sim.sim_moments.moment_num_covs == )
        # assert(sim.sim_moments.variables_mean_ind == )
        # assert(sim.sim_moments.variables_var_ind == )
        # assert(sim.sim_moments.variables_cov_ind == )
        # assert(sim.sim_moments.variables_num_means == )
        # assert(sim.sim_moments.variables_num_vars == )
        # assert(sim.sim_moments.variables_num_covs == )
        # assert(sim.sim_moments.net_hidden_edges == )

    def test_sim_moment_net_min_2_4(self):
        net = me.Network('net_min_2_4')
        net.structure([
            {'start': 'X_t', 'end': 'Y_t',
             'rate_symbol': 'd',
             'type': 'S -> E', 'reaction_steps': 2},
            {'start': 'Y_t', 'end': 'Y_t',
             'rate_symbol': 'l',
             'type': 'S -> S + S', 'reaction_steps': 4}
            ])

        simulation_variables = {'X_t': ('X_t',), 'Y_t': ('Y_t', )}
        mean_only = False
        sim = me.Simulation(net)
        sim.sim_mean_only = mean_only

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_moments.prepare_moment_simulation(sim.sim_variables_order, sim.sim_variables_identifier, mean_only)

        # check all testable attributes for the simulation of this network
        # assert(sim.sim_moments.moment_order_main == )
        # assert(sim.sim_moments.moment_order_hidden == )
        # assert(sim.sim_moments.moment_aux_vars == )
        # assert(sim.sim_moments.moment_aux_vars_dict == )
        # assert(sim.sim_moments.theta_replaceable == )
        # assert(sim.sim_moments.theta_replaceable_dict == )
        # assert(sim.sim_moments.moment_pde == )
        # assert(sim.sim_moments.moment_eqs == )
        # assert(sim.sim_moments.moment_eqs_template_str == )
        # assert(sim.sim_moments.moment_mean_ind == )
        # assert(sim.sim_moments.moment_var_ind_intra == )
        # assert(sim.sim_moments.moment_var_ind_inter == )
        # assert(sim.sim_moments.moment_cov_ind == )
        # assert(sim.sim_moments.moment_num_means == )
        # assert(sim.sim_moments.moment_num_vars == )
        # assert(sim.sim_moments.moment_num_covs == )
        # assert(sim.sim_moments.variables_mean_ind == )
        # assert(sim.sim_moments.variables_var_ind == )
        # assert(sim.sim_moments.variables_cov_ind == )
        # assert(sim.sim_moments.variables_num_means == )
        # assert(sim.sim_moments.variables_num_vars == )
        # assert(sim.sim_moments.variables_num_covs == )
        # assert(sim.sim_moments.net_hidden_edges == )

    def test_sim_moment_net_par2(self):
        net = me.Network('net_par2')
        net.structure([
            {'start': 'X_t', 'end': 'Y_t', 'rate_symbol': 'd4', 'type': 'S -> E', 'reaction_steps': 4},
            {'start': 'X_t', 'end': 'Y_t', 'rate_symbol': 'd2', 'type': 'S -> E', 'reaction_steps': 2},
            {'start': 'Y_t', 'end': 'Y_t', 'rate_symbol': 'l', 'type': 'S -> S + S', 'reaction_steps': 3}
            ])

        simulation_variables = {'X_t': ('X_t',), 'Y_t': ('Y_t', )}
        mean_only = False
        sim = me.Simulation(net)
        sim.sim_mean_only = mean_only

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_moments.prepare_moment_simulation(sim.sim_variables_order, sim.sim_variables_identifier, mean_only)

        # check all testable attributes for the simulation of this network
        # assert(sim.sim_moments.moment_order_main == )
        # assert(sim.sim_moments.moment_order_hidden == )
        # assert(sim.sim_moments.moment_aux_vars == )
        # assert(sim.sim_moments.moment_aux_vars_dict == )
        # assert(sim.sim_moments.theta_replaceable == )
        # assert(sim.sim_moments.theta_replaceable_dict == )
        # assert(sim.sim_moments.moment_pde == )
        # assert(sim.sim_moments.moment_eqs == )
        # assert(sim.sim_moments.moment_eqs_template_str == )
        # assert(sim.sim_moments.moment_mean_ind == )
        # assert(sim.sim_moments.moment_var_ind_intra == )
        # assert(sim.sim_moments.moment_var_ind_inter == )
        # assert(sim.sim_moments.moment_cov_ind == )
        # assert(sim.sim_moments.moment_num_means == )
        # assert(sim.sim_moments.moment_num_vars == )
        # assert(sim.sim_moments.moment_num_covs == )
        # assert(sim.sim_moments.variables_mean_ind == )
        # assert(sim.sim_moments.variables_var_ind == )
        # assert(sim.sim_moments.variables_cov_ind == )
        # assert(sim.sim_moments.variables_num_means == )
        # assert(sim.sim_moments.variables_num_vars == )
        # assert(sim.sim_moments.variables_num_covs == )
        # assert(sim.sim_moments.net_hidden_edges == )

    ### mean-only mode
    def test_sim_moment_net_min_2_4_mean_only(self):
        net = me.Network('net_min_2_4')
        net.structure([
            {'start': 'X_t', 'end': 'Y_t',
             'rate_symbol': 'd',
             'type': 'S -> E', 'reaction_steps': 2},
            {'start': 'Y_t', 'end': 'Y_t',
             'rate_symbol': 'l',
             'type': 'S -> S + S', 'reaction_steps': 4}
            ])

        simulation_variables = {'X_t': ('X_t',), 'Y_t': ('Y_t', )}
        mean_only = True
        sim = me.Simulation(net)
        sim.sim_mean_only = mean_only

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_moments.prepare_moment_simulation(sim.sim_variables_order, sim.sim_variables_identifier, mean_only)

        # check all testable attributes for the simulation of this network
        # assert(sim.sim_moments.moment_order_main == )
        # assert(sim.sim_moments.moment_order_hidden == )
        # assert(sim.sim_moments.moment_aux_vars == )
        # assert(sim.sim_moments.moment_aux_vars_dict == )
        # assert(sim.sim_moments.theta_replaceable == )
        # assert(sim.sim_moments.theta_replaceable_dict == )
        # assert(sim.sim_moments.moment_pde == )
        # assert(sim.sim_moments.moment_eqs == )
        # assert(sim.sim_moments.moment_eqs_template_str == )
        # assert(sim.sim_moments.moment_mean_ind == )
        # assert(sim.sim_moments.moment_var_ind_intra == )
        # assert(sim.sim_moments.moment_var_ind_inter == )
        # assert(sim.sim_moments.moment_cov_ind == )
        # assert(sim.sim_moments.moment_num_means == )
        # assert(sim.sim_moments.moment_num_vars == )
        # assert(sim.sim_moments.moment_num_covs == )
        # assert(sim.sim_moments.variables_mean_ind == )
        # assert(sim.sim_moments.variables_var_ind == )
        # assert(sim.sim_moments.variables_cov_ind == )
        # assert(sim.sim_moments.variables_num_means == )
        # assert(sim.sim_moments.variables_num_vars == )
        # assert(sim.sim_moments.variables_num_covs == )
        # assert(sim.sim_moments.net_hidden_edges == )

    def test_sim_moment_net_par2_mean_only(self):
        net = me.Network('net_par2')
        net.structure([
            {'start': 'X_t', 'end': 'Y_t', 'rate_symbol': 'd4', 'type': 'S -> E', 'reaction_steps': 4},
            {'start': 'X_t', 'end': 'Y_t', 'rate_symbol': 'd2', 'type': 'S -> E', 'reaction_steps': 2},
            {'start': 'Y_t', 'end': 'Y_t', 'rate_symbol': 'l', 'type': 'S -> S + S', 'reaction_steps': 3}
            ])

        simulation_variables = {'X_t': ('X_t',), 'Y_t': ('Y_t', )}
        mean_only = True
        sim = me.Simulation(net)
        sim.sim_mean_only = mean_only

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_moments.prepare_moment_simulation(sim.sim_variables_order, sim.sim_variables_identifier, mean_only)

        # check all testable attributes for the simulation of this network
        # assert(sim.sim_moments.moment_order_main == )
        # assert(sim.sim_moments.moment_order_hidden == )
        # assert(sim.sim_moments.moment_aux_vars == )
        # assert(sim.sim_moments.moment_aux_vars_dict == )
        # assert(sim.sim_moments.theta_replaceable == )
        # assert(sim.sim_moments.theta_replaceable_dict == )
        # assert(sim.sim_moments.moment_pde == )
        # assert(sim.sim_moments.moment_eqs == )
        # assert(sim.sim_moments.moment_eqs_template_str == )
        # assert(sim.sim_moments.moment_mean_ind == )
        # assert(sim.sim_moments.moment_var_ind_intra == )
        # assert(sim.sim_moments.moment_var_ind_inter == )
        # assert(sim.sim_moments.moment_cov_ind == )
        # assert(sim.sim_moments.moment_num_means == )
        # assert(sim.sim_moments.moment_num_vars == )
        # assert(sim.sim_moments.moment_num_covs == )
        # assert(sim.sim_moments.variables_mean_ind == )
        # assert(sim.sim_moments.variables_var_ind == )
        # assert(sim.sim_moments.variables_cov_ind == )
        # assert(sim.sim_moments.variables_num_means == )
        # assert(sim.sim_moments.variables_num_vars == )
        # assert(sim.sim_moments.variables_num_covs == )
        # assert(sim.sim_moments.net_hidden_edges == )

    ### initial values
    def test_sim_moment_net_min_2_4_initial_values_synchronous(self):
        net = me.Network('net_min_2_4')
        net.structure([
            {'start': 'X_t', 'end': 'Y_t',
             'rate_symbol': 'd',
             'type': 'S -> E', 'reaction_steps': 2},
            {'start': 'Y_t', 'end': 'Y_t',
             'rate_symbol': 'l',
             'type': 'S -> S + S', 'reaction_steps': 4}
            ])

        simulation_variables = {'X_t': ('X_t',), 'Y_t': ('Y_t', )}
        mean_only = False
        sim = me.Simulation(net)
        sim.sim_mean_only = mean_only

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_moments.prepare_moment_simulation(sim.sim_variables_order, sim.sim_variables_identifier, mean_only)

    def test_sim_moment_net_par2_initial_values_synchronous(self):
        net = me.Network('net_par2')
        net.structure([
            {'start': 'X_t', 'end': 'Y_t', 'rate_symbol': 'd4', 'type': 'S -> E', 'reaction_steps': 4},
            {'start': 'X_t', 'end': 'Y_t', 'rate_symbol': 'd2', 'type': 'S -> E', 'reaction_steps': 2},
            {'start': 'Y_t', 'end': 'Y_t', 'rate_symbol': 'l', 'type': 'S -> S + S', 'reaction_steps': 3}
            ])

        simulation_variables = {'X_t': ('X_t',), 'Y_t': ('Y_t', )}
        mean_only = False
        sim = me.Simulation(net)
        sim.sim_mean_only = mean_only

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_moments.prepare_moment_simulation(sim.sim_variables_order, sim.sim_variables_identifier, mean_only)

    def test_sim_moment_net_min_2_4_initial_values_uniform(self):
        net = me.Network('net_min_2_4')
        net.structure([
            {'start': 'X_t', 'end': 'Y_t',
             'rate_symbol': 'd',
             'type': 'S -> E', 'reaction_steps': 2},
            {'start': 'Y_t', 'end': 'Y_t',
             'rate_symbol': 'l',
             'type': 'S -> S + S', 'reaction_steps': 4}
            ])

        simulation_variables = {'X_t': ('X_t',), 'Y_t': ('Y_t', )}
        mean_only = False
        sim = me.Simulation(net)
        sim.sim_mean_only = mean_only

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_moments.prepare_moment_simulation(sim.sim_variables_order, sim.sim_variables_identifier, mean_only)

    def test_sim_moment_net_par2_initial_values_uniform(self):
        net = me.Network('net_par2')
        net.structure([
            {'start': 'X_t', 'end': 'Y_t', 'rate_symbol': 'd4', 'type': 'S -> E', 'reaction_steps': 4},
            {'start': 'X_t', 'end': 'Y_t', 'rate_symbol': 'd2', 'type': 'S -> E', 'reaction_steps': 2},
            {'start': 'Y_t', 'end': 'Y_t', 'rate_symbol': 'l', 'type': 'S -> S + S', 'reaction_steps': 3}
            ])

        simulation_variables = {'X_t': ('X_t',), 'Y_t': ('Y_t', )}
        mean_only = False
        sim = me.Simulation(net)
        sim.sim_mean_only = mean_only

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_moments.prepare_moment_simulation(sim.sim_variables_order, sim.sim_variables_identifier, mean_only)
